---
title: 日志上报
date: 2024-02-11 13:59:38
permalink: /pages/a20ce8
---

日常开发中会遇到一些不好确定的因素，比如：线上环境有个 bug, 但是后端返回的数据是正确的，那就是前端的问题，如果线上把日志删除之后那么就不会显示对应的日志；

如果线上环境没有日志，那么就无法知道问题出在哪里，所以需要将日志上报到后端，让后端来查看日志。但是后端说没有任何问题那么就要前端 排查问题了；

前端经过一天一夜的排查，不断的测试，发现还是没有问题； 这样解决问题的效率就会低很多，再加上不确定用户是怎么操作的就会加大难度；

那我直接开发一个上报系统，顺带记录用户操作前 15s 的视频，那么就完全明白用户是怎么操的呢；

::: tip
本系统的开发目的很简单，就是为了在部分情况下搜集前端的异常日志，用于分析异常情况; 如：线上环境的项目我们会吧一些日志删除，如果前端报错那么日志是首选， 这样的情况我们不知道是哪里的报错导致页面崩溃的； 那么开发这款工具常规情况下能解决大部分的问题；
:::

既然确定了开发的需求，那么接下来就要确认需要搜集日志的内容：

1. 资源：资源地址不正确或不存在导致的资源异常
2. 代码：搜集报错信息，页面的崩溃等等；
3. 请求：请求参数错误，访问地址不存在，异常拦截
4. 额外添加功能：支持录制自定义时间的视频，但是最大时间不能超过 1 分钟;

项目底层是用`ts`语言编写的，具体实现的方式可以查看[日志上报 Github](https://github.com/wangxiaoze-view/log-repeorting#readme), 如何安装可以查看[如何安装使用](https://www.npmjs.com/package/log-reporting)

## 元素监听

如果点击按钮操作元素，如何监听到对应的错误信息呢？

**可以通过 addEventListener 监听事件，那么就可以获取到当前操作的元素信息了；**

```js
let lastEvent: any;

// 监听事件，将一些常见的事件添加到全局变量 lastEvent 中
// 那么就能获取到当前操作的元素，那么就能知道用户操作了什么元素了

["click", "touchstart", "mousedown", "keydown", "mouseover"].forEach(
	eventType => {
		document.addEventListener(
			eventType,
			event => {
				lastEvent = event;
				// 如果想要获取stack错误栈信息， 那么 event.error.stack 就可以获取到当前错误行等详细信息
			},
			{
				// 是在捕获阶段还是冒泡阶段执行
				capture: true,
				// 默认不阻止默认事件
				passive: true,
			}
		);
	}
);
```

## 请求， promise 拦截

如果请求或者 promise 出现错误，那么就可以通过拦截器来获取到错误信息了；

```js
window.addEventListener("unhandledrejection", () => {
	//  如果promise发生错误，那么这里是可以获取到信息
});

window.addEventListener(
	"error",
	() => {
		// js,资源拦截：js拦截错误信息, 资源拦截状态
	},
	true
);
```

常见的一些错误信息我们可以通过上面的方式获取信息，那么接下来就需要将这些信息上报到后端了；

上报的方式分为俩种：`fetch` 和 `sendBeacon`；

1. `fetch` 是一个异步请求，`sendBeacon` 是一个同步请求；
2. `fetch` 可以通过`response` 获取到响应状态，`sendBeacon` 不可以；

### 上报

```js
export function sendReport(errorData: Record<string, any>) {
	const params = {
		// 参数包含错误信息，设备信息，浏览器信息等等
	};

	if (logReporting.logMethod === "fetch") {
		fetch("上报的地址", {
			method: "POST",
			body: JSON.stringify(params),
		}).then();
	} else if (logReporting.logMethod === "sendBeacon") {
		navigator.sendBeacon("上报的地址", JSON.stringify(params));
		// navigator.sendBeacon(logReporting.dsn,  new Blob([JSON.stringify(params)], {
		//   type: 'text/plain' // 不指定 type 或者指定为空字符串也是不行的
		// }));
	}
}
```

接下来对于数据那就是后端的事情了；

日志搜集还是比较简单的，无非就是通过拦截的方式对一些错误信息，浏览器信息搜集下来，之后在去请求接口即可；

## 代码地址

- [日志上报 Github](https://github.com/wangxiaoze-view/log-repeorting#readme)
- [如何安装使用](https://www.npmjs.com/package/log-reporting)
