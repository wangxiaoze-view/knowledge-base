---
title: 前端部署通知用户更新网站
date: 2024-04-16 15:54:15
permalink: /pages/feb8e6/
---

对于前端部署如何进行项目部署这里就不详细介绍了，这里主要介绍如何进行前端部署通知用户更新网站。

之前开发的网站, 每次都是让用户手动进行刷新网页打到网站更新的目的,但是这里有一个弊端,就是用户每次都需要手动,对我来讲,我比较懒,能自动的绝不手动刷新;

## 简单介绍

### 场景 1

开发完一个功能, 提交到 github 上, 然后通过`jenkins`去部署发布, 之后你会发现页面还是之前的页面,因为你没有刷新网站,所以需要手动刷新一下网站。对于用户来讲能不能自动更新呢?

### 场景 2

用户在填写表单的时候,你项目网站更新了,需要一个提示,可以立即更新也可以忽略稍后更新, 这样就可以告知用户网站更新了那些功能? 更新的内容会不会影响你正在操作的功能?

### 场景 3

如果没有提示框,直接刷新页面导致用户正在操作的数据丢失, 这样的损失还是比较大的;

于是我今天研究了一下这个网站更新的方案, 然后通过本地`nginx`模拟服务器去尝试了一下;

## 实现的方案

文章使用的是`vite5 + vue3 + ts`的一个本地项目;

1. 使用第三方插件[vite-plugin-pwa](https://vite-pwa-org.netlify.app/), 具体的做法可以参考官网
2. 手动是实现`manifest.json` + 循环`web worker`实现, 就是打包的时候创建一个`manifest.json` 然后将打包时间`Date.now()`写入文件, 之后在根据里面的时间去做对应的逻辑
3. 在`vite.config.ts`中使用`build`, 开启`manifest`,这样每次打包都会在`dist/.vite`中生成一个新的文件, 这个文件就是`manifest.json`

这里我们具体讲`vite.config.js` + `web worker`实现思路:

### 配置 vite.config.ts

`vite.config.ts`如何配置呢? [vite 后端集成](https://cn.vitejs.dev/guide/backend-integration)

```ts
export default defineConfig(() => {
	return {
		plugins: [vue(), eslintPlugin()],
		// 添加下面的build
		build: {
			manifest: true,
			cssCodeSplit: false,
		},
	};
});
```

然后你可以通过`npm run build`命令打包项目,等待项目打包成功之后, 项目根目录生成`dist`目录, 大概的结构为:

```shell
.vite
assets
index.html
vite.svg
```

`.vite`目录就是我们打包的`manifest.json`文件, 这个文件就是我们后面需要读取的; `manifest.json`中`file`就是`index.html`中引入`js,css`的地址;
`index.html`中引入`js,css`的地址为:

```html
<!-- 大概这样的格式 -->
<script type="module" src="/assets/index.c0d0d0e9.js"></script>
<link rel="modulepreload" href="/assets/index.c0d0d0e9.css" />
```

这里`manifest.json`文件可以理解为离线缓存文件, 就是吧所有的资源都缓存起来;

### 实现思路一

想要做到网站更新, 这里要获取`manifest.json`文件,不过现在文件是在`dist/.vite`中, 想要直接读取那就要修改打包命令

```json
"scripts": {
  "build": "vite build && node src/copyManifest.js",
}
```

`copyManifest.js`的文件为就是复制一份`manifest.json`到`dist`目录下

```js
import { copyFileSync } from "fs";
try {
	copyFileSync("dist/.vite/manifest.json", "dist/manifest.json");
} catch (e) {
	console.log(e);
	process.exit(1);
}
```

然后在`main.js`中引入一个文件,这个文件就是你更新网站的核心逻辑了;

大致的思路就是:

1. `fetch('/manifest.json')` 拿到最新的数据和上一次的数据去做比较或者结合`发布订阅模式`
2. 循环获取, 因为网站不定时会更新,所以需要循环; 发现文件地址不一致直接弹框提示;
3. `manifest.json`你也可以手动创建, 那就需要吧`vite.config.ts`中`manifest`关闭, 打包的时候创建一个文件`manifest.json`内容为`{time: 'xxxx', content: '更新内容'}`; 同样的循环操作去对比时间;

不过这样是比较麻烦的, 所以我们使用另外一种`web worker`来实现;

### 实现思路二 <Badge text="推荐使用" type="error"/>

首先需要创建俩个文件`checkUpdate.ts`和`checkUpdate.worker.ts`, 一个是入口文件, 另一个是`web worker`循环检测机制;

```ts
// checkUpdate.ts:
import { ElMessageBox } from "element-plus";
// ./checkUpdate.worker?worker这是vite的写法. 如果使用webpack 是需要下载对应的插件识别的
import CheckWorker from "./checkUpdate.worker?worker";

// 判断是否是开发环境, 如果是开发环境就不需要检测更新
if (import.meta.env.MODE !== "development") {
	const worker = new CheckWorker();

	// 更新弹框
	async function judgeUpdate(lastEtag: string) {
		ElMessageBox.confirm("检测到网站有新内容, 是否需要更新?", "更新提示", {
			confirmButtonText: "立即更新",
			cancelButtonText: "10s之后再通知我",
			type: "warning",
		})
			.then(async () => {
				// 更新操作
				worker.postMessage({
					type: "close",
					tip: "关闭",
					lastEtag,
				});
				location.reload();
			})
			.catch(() => {
				// 稍后更新操作
				// 告知子线程稍后更新
				worker.postMessage({
					type: "recheck",
					tip: "10s之后再通知我",
					lastEtag,
				});
			});
	}

	// 首次进入页面检测是否需要更新
	worker.postMessage({
		type: "check",
		tip: "检测是否更新",
	});

	// 接收到worker更新的消息, 那就进行弹框提示
	worker.onmessage = ({ data }) => {
		// 主线程接收到要更新的通知,那就弹框提示
		if (data.type === "hasUpdate") {
			judgeUpdate(data.lastEtag);
		}
	};
}
```

```ts
// checkUpdate.worker.ts:
let lastEtag: string | null | undefined = undefined;
let hasUpdate = false;

let intervalId: number | null | undefined = null;
async function checkUpdate() {
	// 这里可以读取`manifest.json`, 我在这里直接读取网站的页面
	const res = await fetch(`${self.location.protocol}//${self.location.host}`, {
		method: "HEAD",
		cache: "no-cache",
	});

	// 这一行就是如何判断是否有更新
	const etag = res.headers.get("etag") || res.headers.get("last-modified");
	hasUpdate = lastEtag !== undefined && etag !== lastEtag;

	if (hasUpdate) {
		// 向主线程发送消息, 告诉他网站需要更新了;
		self.postMessage({
			type: "hasUpdate",
			tip: "需要更新",
			lastEtag,
		});
	}
	lastEtag = etag;
}

// 监听worker发送的消息
self.addEventListener("message", ({ data }) => {
	// 检测更新
	if (data.type === "check") {
		checkUpdate();
		intervalId && clearInterval(intervalId);
		intervalId = setInterval(checkUpdate, 10 * 1000);
	} else if (data.type === "recheck") {
		// 稍后通知
		hasUpdate = false;
		lastEtag = data.lastEtag;
		intervalId && clearInterval(intervalId);
		intervalId = setInterval(checkUpdate, 10 * 1000);
	} else if (data.type === "close") {
		// 关闭
		intervalId && clearInterval(intervalId);
		close();
	}
});
```

![流程](https://qiniu.wangxiaoze.wang/hexo-blog/update-2024-04-15-0952.png)

然后在`main.ts`中引入`import './checkUpdate'`; 基本上就可以了;

然后重新打包, 讲打包出来的文件放在本地服务器上;

然后打开页面: 等待时间就会有提示了:

## 视频效果预览

<video controls style="width:100%;height:500px;object-fit:fill;">
  <source src="https://qiniu.wangxiaoze.wang/hexo-blog/web_update.mp4" type="video/mp4" />
</video>
