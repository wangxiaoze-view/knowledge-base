---
title: 初识Flutter
date: 2024-04-14 20:29:17
permalink: /pages/b94f8b/
---

::: tip
💡 有关 Flutter 的介绍，在这里就不做过多的描述；具体介绍请移步至官网阅读；本文仅仅作为日常学习记录；
:::

## 模块代码解析

### 导入包

> Flutter 默认提供了一套 Material 风格的 UI 组件库；

```dart
import 'package:flutter/material.dart';
```

### 应用入口

> main 方法是用了箭头函数，可以理解为前端的箭头函数；

```dart
void main() => runApp(const MyApp());
```

### 应用结构

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // 应用名称
      title: 'Study To Flutter',
      theme: ThemeData(
        // 蓝色主题
        primarySwatch: Colors.blue,
      ),
      // 应用首页组件
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}
```

- MyApp 泪代表着 Flutter 的应用，继承自 StatelessWidget 类，也就是意味着它也是一个 Widget 组件
- 而在 Flutter 中，任何小部件都是一个 Widget；
- 在调用应用时，会出发 build 方法，从而构建应用的 UI；
- MaterialApp 是 Flutter Materil 提供的默认的 App 的框架，同时也是一个 Widget；
- MyHomePage 是应用的首页，同是也是一个 Widget；

## 首页

### Widget 初识

```dart
class MyHomePage extends StatefulWidget {
  MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {}
```

> Widget 主要分为俩大类：

1. StatefullWidget： 有状态的组件；可以拥有状态，在 Widget 生命周期中这些状态是可以改变的；
2. StateLessWidget：无状态的组件；没有任何状态，在 Widget 生命周期中状态不能改变；

> StatefullWidget 有俩个类组成：

1. StatefullWidget 类
2. State 类，StatefullWidget 本身不会发生变化，而 State 会跟着 Widget 的生命周期发生变化；

### State 类

> State 类可以存储一些值的状态，比如计数器：int \_count = 0;

#### 组件的状态：计数器

```dart

// 定义一个可以改变State初始值为_count的方法
void _addCount() {
 setState((){
   _count++;
 })
}
```

当按钮点击是，会出发一个\_addCount()函数，从而将 State 中的\_count 的初始值自增；当状态发生改变后，Flutter 收到发生改变的通知，从而通过 buid 函数重新渲染 UI 界面，即更新视图；

#### 构建 UI，build 构建

构建 UI 界面的逻辑在 build 方法中，当 MyHomePage 第一次创建时，\_MyHomePageState 类会被创建，当初始化完成后，Flutter 框架会调用 widget 的 build 方法来构建 widget 树，最终将 widget 树渲染到设备屏幕上。

计数器案例：当点击按钮之后，会出发改变初始值状态的方法，让初始值自增，FLutter 收到状态只更新的通知，会通过 build 的方法将视图进行更新，重构当前视图；
可参考以下代码：

```dart
// 引入包
import 'package:flutter/material.dart';
// 入口函数
void main(List<String> args) {
  runApp(const MyApp());
}
// myapp 继承 statelesswidget类，
class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // build 默认materialapp框架
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: "study to flutter",
      theme: ThemeData(primaryColor: Colors.greenAccent),
      // 构建主页首页；
      home: const MyHomePage(),
    );
  }
}

// myhomepage继承statefullwidget有状态的类
class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key}) : super(key: key);

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  // 定义文本初始值，有状态的字符
  String _string = "初始化的📄";
  // 定义按钮点击toggle  用于改变文本的默认值
  bool _bool = false;

  // 调用build，构建视图
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("首页"),
        centerTitle: true,
      ),
      body: Column(
        children: [
          // 初始化的文本值
          Text(_string),
          // 文本按钮
          TextButton(
            // 点击之后修改 状态值， 构建显示；
            onPressed: () {
              setState(() {
                if (!_bool) {
                  _string = "点击按钮发生了改变！！！";
                } else {
                  _string = "初始化的📄";
                }
                _bool = !_bool;
              });
            },
            child: const Text('点击按钮Text文本会发生改变！'),
          )
        ],
      ),
    );
  }
}
```

#### build 的方法为什么会在 state 中，而不是 statefullwidget？

- 状态的访问不方便
  如果 statefullwidget 存在很多的状态，每次状态发生改变都会调用 build 去重构视图，构建的构成依赖 state，如果放在 statefullwidget 每次构建都会传一个 state 的值，将 state 的值进行修改；

```dart
Widget build(BuildContext context, State state){}
```

- 继承 statefullwidget 不方便；

## 参考文献

[为什么要将 build 方法放在 State 中，而不是放在 StatefulWidget 中？](https://book.flutterchina.club/chapter2/first_flutter_app.html#_2-1-2-%E9%A6%96%E9%A1%B5)
