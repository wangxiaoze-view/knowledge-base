---
title: 画布的清晰度优化
date: 2024-05-21 13:42:04
permalink: /pages/101a3c/
---

上一章说到了`three`的基础创建以及场景的简单说明，这一章将会在上一章画布的基础上优化画布的清晰度。

首先先说明一下为什么要用`canvas`画布?

原因很简单，使用canvas画布可以更好的兼容低端设备，使其在原有的基础扩展其性能； 就比如：

**你需要使用`threejs`去描述一编写一个商品的信息(商品的属性，颜色，转场动画等等), 如果您直接 `document.body.appendChild(renderer.domElement)`，那么在低端设备上，渲染会非常卡顿，甚至会崩溃; 并且扩展其他功能是比较困难的，但如果您使用`canvas`那么其他的页面布局您就可以使用`css+html`去实现，后期再添加其他场景，那么只需要在`canvas`上添加新的场景即可，而不用担心兼容性问题。**

那么既然使用`canvas`那么就要解决`canvas`画布清晰度的问题了; 清晰度的解决方案放后面说，先说明一下如何使用`canvas`和`three.js`结合使用;

``` html
<div class="layout">
  <header></header>
  <div class="content">
    <canvas id="c"></canvas>
  </div>
  <footer></footer>
</div>
```

``` js
// 使用 three创建一个 物体
import * as THREE from "three";

function main() {
  const canvas = document.querySelector("#c");
  // 使用canvas与threejs结合， antialias 为true 表示开启抗锯齿
  const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });


  // 创建相机
  const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5);
  camera.position.z = 2;

  // 初始场景
  const scene = new THREE.Scene();

  // 添加物体
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshPhongMaterial({ color: 0x44aa88 });
  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  
  // 添加光源
  const light = new THREE.DirectionalLight(0xffffff, 3);
  light.position.set(-1, 2, 4);
  scene.add(light);

  // 渲染
  renderer.render(scene, camera);


  function render(time) {
    time *= 0.001; // 将时间转换为秒

    // 这里需要更新相机矩形以及渲染器大小

    cube.rotation.x = time;
    cube.rotation.y = time;
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  // requestAnimationFrame优化性能
  requestAnimationFrame(render);
}


main()
```

关于画布的清晰度, 离不开属性`window.devicePixelRatio（当前显示设备的物理像素分辨率与CSS 像素分辨率之比）`, 简单的说明: `width * devicePixelRatio`就是画布的宽度， `height * devicePixelRatio`就是画布的高度。那这样就能安装比例去计算对应宽度高度的清晰度问题了;

我们直接封装一个共有的方法：

``` js
// 这里的renderer就是 WebGLRenderer
function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const pixelRatio = window.devicePixelRatio;
  const width = Math.floor(canvas.clientWidth * pixelRatio);
  const height = Math.floor(canvas.clientHeight * pixelRatio);
  // 如果宽或者高比例与画布的宽高不相等，那么就进行更新
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}


function render(time) {
  // ...  time *= 0.001;
  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  // ...
  requestAnimationFrame(render);
}

```
