(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{337:function(v,t,_){"use strict";_.r(t);var a=_(4),e=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("性能优化的方面有很多，这里集中拿"),t("code",[v._v("vue")]),v._v("举例说明（部分方案网上采集的）：")]),v._v(" "),t("h2",{attrs:{id:"条件渲染优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染优化"}},[v._v("#")]),v._v(" 条件渲染优化")]),v._v(" "),t("p",[v._v("条件渲染分为"),t("code",[v._v("v-if和v-show")]),v._v(", 具体俩者的区别可详看之前的文章"),t("a",{attrs:{href:"/pages/23f566"}},[v._v("if 和 show 的区别")])]),v._v(" "),t("ol",[t("li",[t("code",[v._v("v-if")]),v._v("和"),t("code",[v._v("v-show")]),v._v("的区别使用，使用正确可减少 DOM 树的性能开销")]),v._v(" "),t("li",[v._v("避免在"),t("code",[v._v("v-for")]),v._v("中使用"),t("code",[v._v("v-if")]),v._v(" "),t("a",{attrs:{href:"/pages/7e4e7c"}},[v._v("v-for 和 v-if 为什么不能同时使用")])])]),v._v(" "),t("h2",{attrs:{id:"合理利用计算属性和监听器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合理利用计算属性和监听器"}},[v._v("#")]),v._v(" 合理利用计算属性和监听器")]),v._v(" "),t("p",[v._v("关于计算属性和监听器的的详细说明以及区别可可详看之前的文章"),t("a",{attrs:{href:"/pages/14e203"}},[v._v("watch,watcheffect 和 computed 的区别")])]),v._v(" "),t("ol",[t("li",[v._v("合理使用 computed：对于依赖其他数据并需要在多个地方复用的复杂逻辑，使用计算属性可以实现缓存，只在依赖数据变化时才重新计算。")]),v._v(" "),t("li",[v._v("精简 watch：避免在 watch 中执行过于复杂的计算或操作。对于深度监听或大对象的变化，可以结合 deep 和 immediate 选项优化，或者考虑使用 computed 替代。")])]),v._v(" "),t("h2",{attrs:{id:"路由懒加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载"}},[v._v("#")]),v._v(" 路由懒加载")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("动态导入组件")]),v._v(" 使用 import() 语法实现异步加载路由对应的组件，避免在应用启动时一次性加载所有代码，从而减少初始加载时间。")]),v._v(" "),t("li",[t("strong",[v._v("代码分割")]),v._v(" 利用 Webpack 等构建工具的代码分割功能，将大型应用拆分为多个按需加载的块。")])]),v._v(" "),t("h2",{attrs:{id:"列表渲染优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#列表渲染优化"}},[v._v("#")]),v._v(" 列表渲染优化")]),v._v(" "),t("ol",[t("li",[v._v("为 v-for 遍历的元素添加 key 属性：这有助于 Vue 识别并更准确地进行 DOM 更新，通过高效的元素复用和移动，降低不必要的 DOM 操作。")]),v._v(" "),t("li",[v._v("对于长列表, 可以使用滚动加载，分页以及 虚拟列表等优化。")])]),v._v(" "),t("h2",{attrs:{id:"状态管理优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态管理优化"}},[v._v("#")]),v._v(" 状态管理优化")]),v._v(" "),t("ol",[t("li",[v._v("合理设计数据结构：避免过多的深层次嵌套，减少不必要的派生状态和计算属性。")])]),v._v(" "),t("h2",{attrs:{id:"组件优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件优化"}},[v._v("#")]),v._v(" 组件优化")]),v._v(" "),t("ol",[t("li",[v._v("合理设计组件粒度：避免过度细化导致过多组件实例，同时也避免组件过于庞大影响渲染性能。")]),v._v(" "),t("li",[v._v("使用 "),t("code",[v._v("v-once")]),v._v(" 静态内容标记：对于无需更新的静态内容，添加 "),t("code",[v._v("v-once")]),v._v(" 指令以确保它们仅渲染一次，后续不再参与虚拟 "),t("code",[v._v("DOM diff")]),v._v(" 过程。")])]),v._v(" "),t("h2",{attrs:{id:"资源优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源优化"}},[v._v("#")]),v._v(" 资源优化")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("图片懒加载")]),v._v(" 使用第三方库（如 vue-lazyload）实现图片按需加载，提升页面加载速度。")]),v._v(" "),t("li",[t("strong",[v._v("压缩与合并资源")]),v._v(" 对 CSS、JavaScript 文件进行压缩，并合理合并以减少 HTTP 请求次数。")])]),v._v(" "),t("h2",{attrs:{id:"服务端渲染-ssr-或预渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr-或预渲染"}},[v._v("#")]),v._v(" 服务端渲染（SSR）或预渲染")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("对于 SEO 敏感或首屏加载速度要求高的应用")]),v._v("，采用 SSR 或静态预渲染（如 prerender-spa-plugin）来提升初始加载速度和搜索引擎友好性。")])]),v._v(" "),t("h2",{attrs:{id:"性能监测与分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能监测与分析"}},[v._v("#")]),v._v(" 性能监测与分析")]),v._v(" "),t("ol",[t("li",[v._v("使用 Vue DevTools：检查组件渲染、props 变更、状态更新等，识别潜在的性能瓶颈。")]),v._v(" "),t("li",[t("strong",[v._v("性能监控工具")]),v._v("：如 vue-perf-devtool 或第三方服务（如 Google Lighthouse），进行性能基准测试和持续监控。")])]),v._v(" "),t("h2",{attrs:{id:"保持-vue-及依赖项更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#保持-vue-及依赖项更新"}},[v._v("#")]),v._v(" 保持 Vue 及依赖项更新")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("定期升级 Vue 及相关库版本")]),v._v("：新版本通常包含性能改进和 bug 修复，保持更新有利于利用最新优化成果。")])]),v._v(" "),t("p",[v._v("通过综合运用上述策略，可以有效地优化 Vue 应用的性能，提升用户交互体验和应用整体响应速度。记得在实践中根据具体项目需求和性能指标进行有针对性的优化。")])])}),[],!1,null,null,null);t.default=e.exports}}]);