(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{329:function(t,v,_){"use strict";_.r(v);var a=_(4),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("code",[t._v("vue")]),t._v("中的"),v("code",[t._v("watch, watchEffect,computed")]),t._v("是三个不同的工具，用于处理数据响应式和根据数据的改变而执行对应的逻辑。")]),t._v(" "),v("h2",{attrs:{id:"computed"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),v("h3",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("p",[t._v("计算属性。"),v("code",[t._v("computed")]),t._v(" 用于定义那些基于组件状态"),v("code",[t._v("（如 data、其他 computed 属性、props 等）")]),t._v("的衍生值。当其依赖的状态发生变化时，计算属性会自动重新计算并返回结果。")]),t._v(" "),v("h3",{attrs:{id:"特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("缓存机制：")]),t._v(" "),v("code",[t._v("computed")]),t._v("是有缓存的，只有依赖的状态发生变化时，才会重新计算。如果依赖未发生变化，则直接返回之前计算的结果，"),v("strong",[t._v("避免了不必要的重复计算，提高了性能")])]),t._v(" "),v("li",[v("strong",[t._v("声明式：")]),t._v(" 在模板中可直接使用"),v("code",[t._v("computed")]),t._v("属性，就像访问普通函数一样")]),t._v(" "),v("li",[v("strong",[t._v("读取优先：")]),t._v(" "),v("code",[t._v("conputed")]),t._v("主要用于"),v("strong",[t._v("读取")]),t._v("场景，其值由"),v("code",[t._v("vue")]),t._v("自动维护, 通常不建议在业务逻辑中直接修改"),v("code",[t._v("computed")]),t._v("属性, 因为这会破坏依赖追踪机制，导致计算属性的依赖项变化无法触发重新计算。"),v("code",[t._v("computed")]),t._v("默认是可读的状态；")])]),t._v(" "),v("h3",{attrs:{id:"使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),v("ol",[v("li",[t._v("当需要对数据进行复杂计算或者逻辑出库，并且结果仅仅依赖于输入状态时")]),t._v(" "),v("li",[t._v("需要以高效，声明式的方式展示经过处理的数据(格式化，筛选，汇总)")])]),t._v(" "),v("h2",{attrs:{id:"watch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),v("h3",{attrs:{id:"作用-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用-2"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("p",[t._v("响应式监听器， 允许指定单个或者多个数据源(可以是任意数据, 数据属性，对象，数组甚至是"),v("code",[t._v("props, computed")]),t._v(")， 当这数据源的值发生变化并执行回调函数")]),t._v(" "),v("h3",{attrs:{id:"特性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特性-2"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("准确监听：")]),t._v(" 可以精确监听指定的数据源的深度，控制监听粒度")]),t._v(" "),v("li",[v("strong",[t._v("选项丰富：")]),t._v(" 提供了多种选项去定制监听行为，如"),v("code",[t._v("deep深度监听")]),t._v("，"),v("code",[t._v("immediate立即执行")]),t._v(", "),v("code",[t._v("flush队列刷新策略")]),t._v("等")]),t._v(" "),v("li",[v("strong",[t._v("手动控制：")]),t._v(" 回调函数内可以进行复杂的异步操作、资源清理等工作，并能访问到新旧值。")])]),t._v(" "),v("h3",{attrs:{id:"使用场景-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景-2"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),v("ol",[v("li",[t._v("当需要在特定数据变化时执行异步操作、昂贵计算或者进行副作用处理（如更新 DOM、发送网络请求、更新外部状态等）。")]),t._v(" "),v("li",[t._v("需要对数据变化进行精细控制，如深度监听、处理特定类型的变更事件等。")])]),t._v(" "),v("h2",{attrs:{id:"watcheffect"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect"}},[t._v("#")]),t._v(" watchEffect")]),t._v(" "),v("h3",{attrs:{id:"作用-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用-3"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("p",[t._v("自动追踪副作用函数；"),v("code",[t._v("watchEffect")]),t._v("立即执行传入的回调函数，并在此之后持续追踪其内部依赖（所有响应式引用），每当这些依赖变化时，回调函数会再次执行。")]),t._v(" "),v("h3",{attrs:{id:"特性-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特性-3"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("自动搜集依赖：")]),t._v(" 不需要明确指定要监听的数据源，函数体内部访问到的所有响应式数据都会被自动追踪")]),t._v(" "),v("li",[v("strong",[t._v("立即执行：")]),t._v(" 创建时立即运行一次，无需 immediate 选项，默认总是同步执行回调。")]),t._v(" "),v("li",[v("strong",[t._v("关注副作用：")]),t._v(" 更关注于副作用（side effect）的执行，而非具体监听哪个数据的变化。")])]),t._v(" "),v("h3",{attrs:{id:"使用场景-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景-3"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),v("ol",[v("li",[t._v("当需要自动追踪和即时响应所有影响组件状态变化的因素时，无需关心具体是哪些数据变化。")]),t._v(" "),v("li",[t._v("用于处理初始化逻辑或依赖复杂且动态变化的情况，简化代码编写。")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("computed")]),t._v(" 适用于定义基于状态的衍生值，提供高效的缓存机制，常用于视图渲染。")]),t._v(" "),v("li",[v("code",[t._v("watch")]),t._v(" 用于监听特定数据的变化，并在变化时执行特定的回调，适合处理复杂副作用。")]),t._v(" "),v("li",[v("code",[t._v("watchEffect")]),t._v(" 自动追踪副作用函数的依赖，无须指定监听目标，常用于初始化和简单即时响应场景。")])])])}),[],!1,null,null,null);v.default=e.exports}}]);